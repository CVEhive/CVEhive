import logging
import re
import hashlib
from typing import Dict, List, Optional, Tuple
from datetime import datetime
from app.validators.docker_sandbox import DockerSandbox
from app.models import Exploit, ValidationResult
from app.models.base import get_db

class ExploitValidator:
    """Main exploit validation system."""
    
    def __init__(self):
        self.sandbox = DockerSandbox()
        
        # Vulnerability patterns for different CVE types
        self.vulnerability_patterns = {
            'buffer_overflow': [
                r'strcpy|strcat|sprintf|gets|scanf',
                r'buffer\s*overflow',
                r'stack\s*overflow',
                r'heap\s*overflow'
            ],
            'sql_injection': [
                r'union\s+select',
                r'or\s+1\s*=\s*1',
                r'drop\s+table',
                r'insert\s+into',
                r'delete\s+from'
            ],
            'xss': [
                r'<script>',
                r'javascript:',
                r'onerror\s*=',
                r'onload\s*='
            ],
            'rce': [
                r'system\s*\(',
                r'exec\s*\(',
                r'shell_exec',
                r'passthru',
                r'eval\s*\(',
                r'os\.system',
                r'subprocess\.',
                r'Runtime\.getRuntime'
            ],
            'privilege_escalation': [
                r'sudo\s+',
                r'setuid',
                r'chmod\s+[47]',
                r'chown\s+root',
                r'su\s+-'
            ]
        }
        
        # Language-specific dangerous functions
        self.dangerous_functions = {
            'python': [
                'eval', 'exec', 'compile', '__import__', 'getattr',
                'os.system', 'subprocess.call', 'subprocess.run'
            ],
            'c': [
                'system', 'strcpy', 'strcat', 'sprintf', 'gets',
                'scanf', 'malloc', 'free'
            ],
            'php': [
                'eval', 'system', 'exec', 'shell_exec', 'passthru',
                'file_get_contents', 'include', 'require'
            ],
            'javascript': [
                'eval', 'Function', 'setTimeout', 'setInterval',
                'document.write', 'innerHTML'
            ]
        }
    
    def validate_exploit(self, exploit: Exploit, 
                        target_config: Optional[Dict] = None,
                        validation_level: str = 'basic') -> ValidationResult:
        """
        Validate an exploit through multiple stages.
        
        Args:
            exploit (Exploit): The exploit to validate
            target_config (Dict, optional): Target configuration for testing
            validation_level (str): Level of validation ('basic', 'standard', 'comprehensive')
            
        Returns:
            ValidationResult: Validation results
        """
        logging.info(f"Starting validation for exploit {exploit.id}")
        
        validation_result = ValidationResult(
            exploit_id=exploit.id,
            validation_level=validation_level,
            started_at=datetime.utcnow()
        )
        
        try:
            # Stage 1: Static Analysis
            static_analysis = self._perform_static_analysis(exploit)
            validation_result.static_analysis_results = static_analysis
            
            # Stage 2: Syntax Validation
            syntax_validation = self._validate_syntax(exploit)
            validation_result.syntax_valid = syntax_validation['valid']
            validation_result.syntax_errors = syntax_validation.get('errors', [])
            
            # Stage 3: Security Analysis
            security_analysis = self._perform_security_analysis(exploit)
            validation_result.security_analysis_results = security_analysis
            
            # Stage 4: Dynamic Execution (if sandbox available)
            if self.sandbox.is_available() and validation_level in ['standard', 'comprehensive']:
                execution_result = self._execute_exploit(exploit, target_config)
                validation_result.execution_successful = execution_result.get('success', False)
                validation_result.execution_output = execution_result.get('output', '')
                validation_result.execution_errors = execution_result.get('error', '')
                validation_result.execution_time = execution_result.get('execution_time', 0)
            
            # Stage 5: Comprehensive Testing (if requested)
            if validation_level == 'comprehensive' and target_config:
                comprehensive_result = self._comprehensive_testing(exploit, target_config)
                validation_result.target_validation_results = comprehensive_result
            
            # Calculate overall score
            validation_result.validation_score = self._calculate_validation_score(validation_result)
            
            # Determine if exploit is validated
            validation_result.is_validated = self._determine_validation_status(validation_result)
            
            validation_result.completed_at = datetime.utcnow()
            validation_result.validation_status = 'completed'
            
            # Save to database
            self._save_validation_result(validation_result)
            
            logging.info(f"Validation completed for exploit {exploit.id} with score {validation_result.validation_score}")
            
        except Exception as e:
            logging.error(f"Validation failed for exploit {exploit.id}: {str(e)}")
            validation_result.validation_status = 'failed'
            validation_result.validation_errors = [str(e)]
            validation_result.completed_at = datetime.utcnow()
            
            # Save failed result
            self._save_validation_result(validation_result)
        
        return validation_result
    
    def _perform_static_analysis(self, exploit: Exploit) -> Dict:
        """Perform static code analysis on the exploit."""
        analysis = {
            'code_length': 0,
            'complexity_score': 0,
            'vulnerability_indicators': [],
            'dangerous_functions': [],
            'imports_used': [],
            'network_operations': False,
            'file_operations': False,
            'system_calls': False
        }
        
        # Get exploit code
        code = self._get_exploit_code(exploit)
        if not code:
            return analysis
        
        analysis['code_length'] = len(code)
        
        # Detect vulnerability patterns
        for vuln_type, patterns in self.vulnerability_patterns.items():
            for pattern in patterns:
                if re.search(pattern, code, re.IGNORECASE):
                    analysis['vulnerability_indicators'].append(vuln_type)
        
        # Detect dangerous functions
        language = exploit.language.lower() if exploit.language else 'unknown'
        if language in self.dangerous_functions:
            for func in self.dangerous_functions[language]:
                if func in code:
                    analysis['dangerous_functions'].append(func)
        
        # Detect imports/includes
        import_patterns = [
            r'import\s+(\w+)',
            r'from\s+(\w+)\s+import',
            r'#include\s*<(\w+)>',
            r'require\s*\(\s*[\'"](\w+)[\'"]',
            r'include\s*\(\s*[\'"](\w+)[\'"]'
        ]
        
        for pattern in import_patterns:
            matches = re.findall(pattern, code, re.IGNORECASE)
            analysis['imports_used'].extend(matches)
        
        # Detect operation types
        network_indicators = ['socket', 'connect', 'bind', 'listen', 'send', 'recv', 'http', 'url']
        file_indicators = ['open', 'read', 'write', 'file', 'fopen', 'fread', 'fwrite']
        system_indicators = ['system', 'exec', 'shell', 'cmd', 'subprocess', 'popen']
        
        code_lower = code.lower()
        analysis['network_operations'] = any(indicator in code_lower for indicator in network_indicators)
        analysis['file_operations'] = any(indicator in code_lower for indicator in file_indicators)
        analysis['system_calls'] = any(indicator in code_lower for indicator in system_indicators)
        
        # Calculate complexity score
        analysis['complexity_score'] = self._calculate_complexity_score(code)
        
        return analysis
    
    def _validate_syntax(self, exploit: Exploit) -> Dict:
        """Validate syntax of exploit code."""
        result = {'valid': False, 'errors': []}
        
        code = self._get_exploit_code(exploit)
        if not code:
            result['errors'].append('No code found to validate')
            return result
        
        language = exploit.language.lower() if exploit.language else 'unknown'
        
        try:
            if language == 'python':
                compile(code, '<string>', 'exec')
            elif language in ['c', 'cpp']:
                # For C/C++, we'd need a more sophisticated check
                # For now, just check for basic syntax patterns
                if not re.search(r'int\s+main\s*\(', code) and not re.search(r'#include', code):
                    result['errors'].append('Missing main function or includes')
                    return result
            elif language == 'javascript':
                # Basic JavaScript syntax check (simplified)
                if code.count('{') != code.count('}'):
                    result['errors'].append('Mismatched braces')
                    return result
            
            result['valid'] = True
            
        except SyntaxError as e:
            result['errors'].append(f'Syntax error: {str(e)}')
        except Exception as e:
            result['errors'].append(f'Validation error: {str(e)}')
        
        return result
    
    def _perform_security_analysis(self, exploit: Exploit) -> Dict:
        """Perform security-focused analysis of the exploit."""
        analysis = {
            'risk_level': 'low',
            'security_concerns': [],
            'exploit_techniques': [],
            'target_platforms': [],
            'potential_impact': []
        }
        
        code = self._get_exploit_code(exploit)
        if not code:
            return analysis
        
        code_lower = code.lower()
        
        # Analyze exploit techniques
        techniques = {
            'buffer_overflow': ['strcpy', 'strcat', 'sprintf', 'buffer overflow'],
            'sql_injection': ['union select', 'or 1=1', 'drop table'],
            'xss': ['<script>', 'javascript:', 'onerror='],
            'rce': ['system(', 'exec(', 'shell_exec', 'eval('],
            'privilege_escalation': ['sudo', 'setuid', 'chmod 777'],
            'network_attack': ['socket', 'connect', 'bind', 'listen'],
            'file_manipulation': ['fopen', 'fwrite', 'unlink', 'chmod'],
            'memory_corruption': ['malloc', 'free', 'memcpy', 'strcpy']
        }
        
        for technique, indicators in techniques.items():
            if any(indicator in code_lower for indicator in indicators):
                analysis['exploit_techniques'].append(technique)
        
        # Determine risk level
        high_risk_indicators = ['system(', 'exec(', 'shell_exec', 'eval(', 'sudo', 'rm -rf']
        medium_risk_indicators = ['socket', 'connect', 'file', 'malloc']
        
        if any(indicator in code_lower for indicator in high_risk_indicators):
            analysis['risk_level'] = 'high'
        elif any(indicator in code_lower for indicator in medium_risk_indicators):
            analysis['risk_level'] = 'medium'
        
        # Identify security concerns
        if 'system(' in code_lower or 'exec(' in code_lower:
            analysis['security_concerns'].append('Direct system command execution')
        
        if 'eval(' in code_lower:
            analysis['security_concerns'].append('Dynamic code evaluation')
        
        if 'sudo' in code_lower:
            analysis['security_concerns'].append('Privilege escalation attempt')
        
        if any(pattern in code_lower for pattern in ['rm -rf', 'del /f', 'format']):
            analysis['security_concerns'].append('Destructive file operations')
        
        # Identify target platforms
        platform_indicators = {
            'windows': ['windows', 'win32', 'cmd.exe', 'powershell'],
            'linux': ['linux', 'bash', '/bin/sh', 'sudo'],
            'web': ['http', 'html', 'php', 'javascript'],
            'network': ['socket', 'tcp', 'udp', 'port']
        }
        
        for platform, indicators in platform_indicators.items():
            if any(indicator in code_lower for indicator in indicators):
                analysis['target_platforms'].append(platform)
        
        # Assess potential impact
        if 'shell' in code_lower or 'cmd' in code_lower:
            analysis['potential_impact'].append('Remote shell access')
        
        if 'file' in code_lower or 'read' in code_lower:
            analysis['potential_impact'].append('File system access')
        
        if 'network' in code_lower or 'socket' in code_lower:
            analysis['potential_impact'].append('Network communication')
        
        return analysis
    
    def _execute_exploit(self, exploit: Exploit, target_config: Optional[Dict] = None) -> Dict:
        """Execute exploit in sandbox environment."""
        if not self.sandbox.is_available():
            return {'success': False, 'error': 'Sandbox not available'}
        
        code = self._get_exploit_code(exploit)
        if not code:
            return {'success': False, 'error': 'No code to execute'}
        
        language = exploit.language.lower() if exploit.language else 'python'
        
        # Basic execution without target
        if not target_config:
            return self.sandbox.execute_exploit(
                code, 
                language, 
                timeout=30, 
                network_enabled=False
            )
        
        # Execution with target
        return self.sandbox.execute_with_target(
            code, 
            target_config, 
            language, 
            timeout=60
        )
    
    def _comprehensive_testing(self, exploit: Exploit, target_config: Dict) -> Dict:
        """Perform comprehensive testing with multiple scenarios."""
        results = {
            'scenarios_tested': 0,
            'successful_exploits': 0,
            'scenario_results': []
        }
        
        # Test different scenarios
        scenarios = [
            {'name': 'default', 'config': target_config},
            {'name': 'hardened', 'config': {**target_config, 'security_level': 'high'}},
            {'name': 'minimal', 'config': {**target_config, 'minimal_setup': True}}
        ]
        
        for scenario in scenarios:
            try:
                result = self._execute_exploit(exploit, scenario['config'])
                
                scenario_result = {
                    'scenario_name': scenario['name'],
                    'success': result.get('success', False),
                    'output': result.get('output', ''),
                    'execution_time': result.get('execution_time', 0),
                    'analysis': result.get('analysis', {})
                }
                
                results['scenario_results'].append(scenario_result)
                results['scenarios_tested'] += 1
                
                if result.get('success'):
                    results['successful_exploits'] += 1
                    
            except Exception as e:
                logging.error(f"Error in scenario {scenario['name']}: {str(e)}")
                continue
        
        return results
    
    def _calculate_complexity_score(self, code: str) -> float:
        """Calculate code complexity score."""
        if not code:
            return 0.0
        
        score = 0.0
        
        # Line count factor
        lines = len(code.split('\n'))
        score += min(lines / 100.0, 2.0)  # Max 2 points for length
        
        # Control structure complexity
        control_structures = ['if', 'for', 'while', 'switch', 'case', 'try', 'catch']
        for structure in control_structures:
            count = len(re.findall(rf'\b{structure}\b', code, re.IGNORECASE))
            score += count * 0.1
        
        # Function/method count
        function_patterns = [r'def\s+\w+', r'function\s+\w+', r'\w+\s*\(.*\)\s*{']
        for pattern in function_patterns:
            count = len(re.findall(pattern, code, re.IGNORECASE))
            score += count * 0.2
        
        # Import/include complexity
        import_count = len(re.findall(r'(import|include|require)', code, re.IGNORECASE))
        score += import_count * 0.1
        
        return min(score, 10.0)  # Cap at 10
    
    def _calculate_validation_score(self, validation_result: ValidationResult) -> float:
        """Calculate overall validation score."""
        score = 0.0
        
        # Syntax validation (20%)
        if validation_result.syntax_valid:
            score += 2.0
        
        # Static analysis (30%)
        static_results = validation_result.static_analysis_results or {}
        if static_results.get('vulnerability_indicators'):
            score += 1.5  # Has vulnerability indicators
        if static_results.get('complexity_score', 0) > 2:
            score += 1.5  # Reasonable complexity
        
        # Security analysis (25%)
        security_results = validation_result.security_analysis_results or {}
        if security_results.get('exploit_techniques'):
            score += 1.5  # Uses known techniques
        if security_results.get('risk_level') in ['medium', 'high']:
            score += 1.0  # Has security impact
        
        # Execution results (25%)
        if validation_result.execution_successful:
            score += 2.5  # Successfully executed
        
        # Bonus for comprehensive testing
        if validation_result.target_validation_results:
            target_results = validation_result.target_validation_results
            success_rate = target_results.get('successful_exploits', 0) / max(target_results.get('scenarios_tested', 1), 1)
            score += success_rate * 1.0
        
        return min(score, 10.0)  # Cap at 10
    
    def _determine_validation_status(self, validation_result: ValidationResult) -> bool:
        """Determine if exploit is considered validated."""
        # Minimum requirements for validation
        requirements = [
            validation_result.syntax_valid,  # Must have valid syntax
            validation_result.validation_score >= 5.0,  # Minimum score threshold
        ]
        
        # Additional requirements based on validation level
        if validation_result.validation_level in ['standard', 'comprehensive']:
            requirements.append(validation_result.execution_successful)
        
        return all(requirements)
    
    def _get_exploit_code(self, exploit: Exploit) -> str:
        """Extract exploit code from various sources."""
        # Try to get code from different fields
        if hasattr(exploit, 'code') and exploit.code:
            return exploit.code
        
        if hasattr(exploit, 'content') and exploit.content:
            return exploit.content
        
        # If no direct code, try to fetch from URL
        if exploit.url:
            try:
                import requests
                response = requests.get(exploit.url, timeout=10)
                if response.status_code == 200:
                    return response.text
            except Exception as e:
                logging.warning(f"Failed to fetch code from URL {exploit.url}: {str(e)}")
        
        return ""
    
    def _save_validation_result(self, validation_result: ValidationResult):
        """Save validation result to database."""
        try:
            with get_db() as db:
                db.add(validation_result)
                db.commit()
                logging.info(f"Saved validation result for exploit {validation_result.exploit_id}")
        except Exception as e:
            logging.error(f"Failed to save validation result: {str(e)}")
    
    def validate_batch(self, exploits: List[Exploit], 
                      validation_level: str = 'basic',
                      max_concurrent: int = 3) -> List[ValidationResult]:
        """
        Validate multiple exploits in batch.
        
        Args:
            exploits (List[Exploit]): List of exploits to validate
            validation_level (str): Validation level
            max_concurrent (int): Maximum concurrent validations
            
        Returns:
            List[ValidationResult]: List of validation results
        """
        results = []
        
        # For now, process sequentially (could be improved with threading)
        for exploit in exploits:
            try:
                result = self.validate_exploit(exploit, validation_level=validation_level)
                results.append(result)
            except Exception as e:
                logging.error(f"Batch validation failed for exploit {exploit.id}: {str(e)}")
                continue
        
        return results
    
    def get_validation_statistics(self) -> Dict:
        """Get validation statistics."""
        try:
            with get_db() as db:
                total_validations = db.query(ValidationResult).count()
                successful_validations = db.query(ValidationResult).filter(
                    ValidationResult.is_validated == True
                ).count()
                
                avg_score = db.query(ValidationResult).filter(
                    ValidationResult.validation_score.isnot(None)
                ).with_entities(ValidationResult.validation_score).all()
                
                avg_score_value = sum(score[0] for score in avg_score) / len(avg_score) if avg_score else 0
                
                return {
                    'total_validations': total_validations,
                    'successful_validations': successful_validations,
                    'success_rate': successful_validations / max(total_validations, 1),
                    'average_score': avg_score_value,
                    'sandbox_available': self.sandbox.is_available()
                }
                
        except Exception as e:
            logging.error(f"Failed to get validation statistics: {str(e)}")
            return {
                'total_validations': 0,
                'successful_validations': 0,
                'success_rate': 0,
                'average_score': 0,
                'sandbox_available': False
            } 