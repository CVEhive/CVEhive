from sqlalchemy import Column, String, Text, Integer, Boolean, DateTime, JSON, ForeignKey, Index, Enum
from sqlalchemy.orm import relationship
from enum import Enum as PyEnum
from .base import BaseModel

class ExploitSource(PyEnum):
    """Enum for exploit sources."""
    GITHUB = "github"
    EXPLOITDB = "exploitdb"
    METASPLOIT = "metasploit"
    CUSTOM = "custom"

class ExploitStatus(PyEnum):
    """Enum for exploit validation status."""
    PENDING = "pending"
    VALIDATED = "validated"
    FAILED = "failed"
    TIMEOUT = "timeout"
    ERROR = "error"

class Exploit(BaseModel):
    """Exploit model for storing exploit code and metadata."""
    __tablename__ = 'exploits'
    
    # Foreign Key to CVE
    cve_id = Column(Integer, ForeignKey('cves.id'), nullable=False, index=True)
    
    # Basic Information
    title = Column(String(500), nullable=False)
    description = Column(Text, nullable=True)
    author = Column(String(200), nullable=True)
    
    # Source Information
    source = Column(Enum(ExploitSource), nullable=False, index=True)
    source_url = Column(String(1000), nullable=False)
    source_id = Column(String(100), nullable=True)  # GitHub repo ID, ExploitDB ID, etc.
    
    # Code and Files
    exploit_code = Column(Text, nullable=True)
    file_path = Column(String(500), nullable=True)  # Path to exploit file if stored locally
    file_type = Column(String(50), nullable=True)  # py, rb, c, sh, etc.
    
    # Exploit Metadata
    programming_language = Column(String(50), nullable=True, index=True)
    exploit_type = Column(String(100), nullable=True)  # RCE, SQLi, XSS, etc.
    platform = Column(String(100), nullable=True)  # Windows, Linux, Web, etc.
    
    # Validation Information
    validation_status = Column(Enum(ExploitStatus), default=ExploitStatus.PENDING, index=True)
    validation_date = Column(DateTime, nullable=True)
    validation_notes = Column(Text, nullable=True)
    
    # GitHub Specific Fields
    github_stars = Column(Integer, default=0)
    github_forks = Column(Integer, default=0)
    github_updated = Column(DateTime, nullable=True)
    github_language = Column(String(50), nullable=True)
    
    # ExploitDB Specific Fields
    exploitdb_id = Column(Integer, nullable=True, unique=True)
    exploitdb_verified = Column(Boolean, default=False)
    
    # Quality Indicators
    confidence_score = Column(Integer, default=0)  # 0-100 confidence in exploit quality
    popularity_score = Column(Integer, default=0)  # Based on stars, forks, downloads
    
    # Additional Metadata
    tags = Column(JSON, nullable=True)  # List of tags
    requirements = Column(JSON, nullable=True)  # List of requirements/dependencies
    raw_data = Column(JSON, nullable=True)  # Original data from source
    
    # Relationships
    cve = relationship("CVE", back_populates="exploits")
    validation_results = relationship("ValidationResult", back_populates="exploit", cascade="all, delete-orphan")
    
    # Indexes
    __table_args__ = (
        Index('idx_exploit_cve_source', 'cve_id', 'source'),
        Index('idx_exploit_validation', 'validation_status', 'validation_date'),
        Index('idx_exploit_quality', 'confidence_score', 'popularity_score'),
    )
    
    def __repr__(self):
        return f"<Exploit(title='{self.title[:50]}...', source='{self.source.value}')>"
    
    @property
    def is_validated(self):
        """Check if exploit has been successfully validated."""
        return self.validation_status == ExploitStatus.VALIDATED
    
    @property
    def source_display_name(self):
        """Get human-readable source name."""
        source_names = {
            ExploitSource.GITHUB: "GitHub",
            ExploitSource.EXPLOITDB: "Exploit-DB",
            ExploitSource.METASPLOIT: "Metasploit",
            ExploitSource.CUSTOM: "Custom"
        }
        return source_names.get(self.source, str(self.source.value))
    
    @property
    def quality_rating(self):
        """Calculate overall quality rating."""
        # Combine confidence and popularity scores
        confidence_weight = 0.7
        popularity_weight = 0.3
        
        quality = (self.confidence_score * confidence_weight + 
                  self.popularity_score * popularity_weight)
        
        # Boost for validated exploits
        if self.is_validated:
            quality *= 1.2
            
        return min(100, max(0, int(quality)))
    
    @property
    def file_extension(self):
        """Get file extension from file_path or determine from language."""
        if self.file_path:
            return self.file_path.split('.')[-1].lower()
        
        # Map programming languages to extensions
        lang_map = {
            'python': 'py',
            'ruby': 'rb',
            'c': 'c',
            'c++': 'cpp',
            'java': 'java',
            'javascript': 'js',
            'shell': 'sh',
            'powershell': 'ps1',
            'perl': 'pl',
            'php': 'php'
        }
        
        return lang_map.get(self.programming_language.lower(), 'txt') if self.programming_language else 'txt'
    
    def calculate_popularity_score(self):
        """Calculate popularity score based on source metrics."""
        if self.source == ExploitSource.GITHUB:
            # GitHub popularity based on stars and forks
            stars = self.github_stars or 0
            forks = self.github_forks or 0
            
            # Weighted score (stars worth more than forks)
            score = (stars * 2 + forks) / 3
            
            # Normalize to 0-100 scale (log scale for high values)
            if score > 100:
                score = 100 + (score - 100) / 10
            
            return min(100, max(0, int(score)))
        
        elif self.source == ExploitSource.EXPLOITDB:
            # ExploitDB verified exploits get higher score
            return 80 if self.exploitdb_verified else 60
        
        return 50  # Default score for other sources
    
    def to_dict(self):
        """Convert to dictionary with additional computed fields."""
        data = super().to_dict()
        data.update({
            'is_validated': self.is_validated,
            'source_display_name': self.source_display_name,
            'quality_rating': self.quality_rating,
            'file_extension': self.file_extension,
            'validation_status': self.validation_status.value if self.validation_status else None,
            'source': self.source.value if self.source else None
        })
        return data 